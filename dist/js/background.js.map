{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACP,sBAAsB,mCAAmC;AACzD,0CAA0C,wBAAwB;AAClE,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,qBAAqB;AACjC,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACO;AACP;AACA;AACA,kDAAkD;AAClD;AACA,kCAAkC,2BAA2B;AAC7D,6CAA6C,iBAAiB;AAC9D;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,MAAM;AAC7B;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;ACnI8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,uBAAuB,cAAc;AACrC;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA,IAAI,gEAAmB;AACvB;AACA;AACA;AACO;AACP;AACA,EAAE,wDAAU;AACZ;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,+CAA+C,OAAO;AACtD,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA,GAAG;AACH;;;;;;;SC3QA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;ACNgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAuC;AAC7D,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,iCAAiC,kBAAkB;AACnD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wCAAwC;AAC9C;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,qBAAqB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oDAAoD,gBAAgB;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qDAAqD,gBAAgB;AACrE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wDAAwD,gBAAgB;AACxE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,yBAAyB,iBAAiB,+BAA+B,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wEAAwE,0BAA0B;AAClG;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,yBAAyB,iBAAiB,aAAa,MAAM;AAC7D;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC,gCAAgC,gBAAgB,8CAA8C,6BAA6B,OAAO,OAAO;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,kCAAkC,iBAAiB,8CAA8C,6BAA6B,OAAO,OAAO;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,8CAA8C,4BAA4B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,sBAAsB;AAClC,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM,4CAA4C;AAClD;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,UAAU;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C,QAAQ;AACR;AACA,yBAAyB,0CAA0C;AACnE,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kBAAkB,sDAAsD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA,6BAA6B,cAAc,mBAAmB;AAC9D,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA,cAAc,gBAAgB;AAC9B;AACA,mCAAmC,sBAAsB;AACzD;AACA,YAAY,oBAAoB;AAChC;AACA,8BAA8B;AAC9B,mCAAmC,mBAAmB;AACtD;AACA,YAAY,kBAAkB;AAC9B;AACA,0BAA0B,4EAAyB;AACnD,mCAAmC,iBAAiB;AACpD;AACA,MAAM,mEAAgB;AACtB;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA,cAAc,gBAAgB;AAC9B;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B;AACvE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA","sources":["webpack:///./src/common_lib.js","webpack:///./src/context_menu_lib.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/background.js"],"sourcesContent":["export function request_unhighlight(lemma) {\r\n  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\r\n    chrome.tabs.sendMessage(tabs[0].id, { wdm_unhighlight: lemma })\r\n  })\r\n}\r\n\r\nexport function make_id_suffix(text) {\r\n  const before = btoa(text)\r\n  const after = before\r\n    .replace(/\\+/g, '_')\r\n    .replace(/\\//g, '-')\r\n    .replace(/=/g, '_')\r\n  return after\r\n}\r\n\r\nexport function sync_if_needed() {\r\n  const req_keys = ['wd_last_sync', 'wd_gd_sync_enabled', 'wd_last_sync_error']\r\n  chrome.storage.local.get(req_keys, function (result) {\r\n    const { wd_last_sync } = result\r\n    const { wd_gd_sync_enabled } = result\r\n    const { wd_last_sync_error } = result\r\n    if (!wd_gd_sync_enabled || wd_last_sync_error != null) {\r\n      return\r\n    }\r\n    const cur_date = new Date()\r\n    const mins_passed = (cur_date.getTime() - wd_last_sync) / (60 * 1000)\r\n    const sync_period_mins = 30\r\n    if (mins_passed >= sync_period_mins) {\r\n      chrome.runtime.sendMessage({\r\n        wdm_request: 'gd_sync',\r\n        interactive_mode: false,\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nexport function add_lexeme(lexeme, result_handler) {\r\n  const req_keys = [\r\n    'words_discoverer_eng_dict',\r\n    'wd_idioms',\r\n    'wd_user_vocabulary',\r\n    'wd_user_vocab_added',\r\n    'wd_user_vocab_deleted',\r\n  ]\r\n  chrome.storage.local.get(req_keys, function (result) {\r\n    const dict_words = result.words_discoverer_eng_dict\r\n    const dict_idioms = result.wd_idioms\r\n    const user_vocabulary = result.wd_user_vocabulary\r\n    const { wd_user_vocab_added } = result\r\n    const { wd_user_vocab_deleted } = result\r\n    if (lexeme.length > 100) {\r\n      result_handler('bad', undefined)\r\n      return\r\n    }\r\n    lexeme = lexeme.toLowerCase()\r\n    lexeme = lexeme.trim()\r\n    if (!lexeme) {\r\n      result_handler('bad', undefined)\r\n      return\r\n    }\r\n\r\n    let key = lexeme\r\n    if (dict_words.hasOwnProperty(lexeme)) {\r\n      const wf = dict_words[lexeme]\r\n      if (wf) {\r\n        const [first] = wf\r\n        key = first\r\n      }\r\n    } else if (dict_idioms.hasOwnProperty(lexeme)) {\r\n      const wf = dict_idioms[lexeme]\r\n      if (wf && wf !== -1) {\r\n        key = wf\r\n      }\r\n    }\r\n\r\n    if (user_vocabulary.hasOwnProperty(key)) {\r\n      result_handler('exists', key)\r\n      return\r\n    }\r\n\r\n    const new_state = { wd_user_vocabulary: user_vocabulary }\r\n\r\n    user_vocabulary[key] = 1\r\n    if (typeof wd_user_vocab_added !== 'undefined') {\r\n      wd_user_vocab_added[key] = 1\r\n      new_state.wd_user_vocab_added = wd_user_vocab_added\r\n    }\r\n    if (typeof wd_user_vocab_deleted !== 'undefined') {\r\n      delete wd_user_vocab_deleted[key]\r\n      new_state.wd_user_vocab_deleted = wd_user_vocab_deleted\r\n    }\r\n\r\n    chrome.storage.local.set(new_state, function () {\r\n      sync_if_needed()\r\n      result_handler('ok', key)\r\n    })\r\n  })\r\n}\r\n\r\nexport function make_hl_style(hl_params) {\r\n  if (!hl_params.enabled) return undefined\r\n  let result = ''\r\n  if (hl_params.bold) result += 'font-weight:bold;'\r\n  if (hl_params.useBackground)\r\n    result += `background-color:${hl_params.backgroundColor};`\r\n  if (hl_params.useColor) result += `color:${hl_params.color};`\r\n  if (!result) return undefined\r\n  result += 'font-size:inherit;display:inline;'\r\n  return result\r\n}\r\n\r\nexport function localizeHtmlPage() {\r\n  // Localize by replacing __MSG_***__ meta tags\r\n  const objects = document.getElementsByTagName('html')\r\n  for (let j = 0; j < objects.length; j++) {\r\n    const obj = objects[j]\r\n    const valStrH = obj.innerHTML.toString()\r\n    const valNewH = valStrH.replace(/__MSG_(\\w+)__/g, function (match, v1) {\r\n      return v1 ? chrome.i18n.getMessage(v1) : ''\r\n    })\r\n    if (valNewH !== valStrH) {\r\n      obj.innerHTML = valNewH\r\n    }\r\n  }\r\n}\r\n\r\nexport function spformat(src, ...args) {\r\n  // const args = Array.prototype.slice.call(arguments, 1)\r\n  return src.replace(/{(\\d+)}/g, function (match, number) {\r\n    return typeof args[number] !== 'undefined' ? args[number] : match\r\n  })\r\n}\r\n","import { request_unhighlight, add_lexeme } from './common_lib'\r\n\r\nconst isoLangs = {\r\n  ab: 'Abkhaz',\r\n  aa: 'Afar',\r\n  af: 'Afrikaans',\r\n  ak: 'Akan',\r\n  sq: 'Albanian',\r\n  am: 'Amharic',\r\n  ar: 'Arabic',\r\n  an: 'Aragonese',\r\n  hy: 'Armenian',\r\n  as: 'Assamese',\r\n  av: 'Avaric',\r\n  ae: 'Avestan',\r\n  ay: 'Aymara',\r\n  az: 'Azerbaijani',\r\n  bm: 'Bambara',\r\n  ba: 'Bashkir',\r\n  eu: 'Basque',\r\n  be: 'Belarusian',\r\n  bn: 'Bengali',\r\n  bh: 'Bihari',\r\n  bi: 'Bislama',\r\n  bs: 'Bosnian',\r\n  br: 'Breton',\r\n  bg: 'Bulgarian',\r\n  my: 'Burmese',\r\n  ca: 'Catalan',\r\n  ch: 'Chamorro',\r\n  ce: 'Chechen',\r\n  ny: 'Chichewa',\r\n  zh: 'Chinese',\r\n  cv: 'Chuvash',\r\n  kw: 'Cornish',\r\n  co: 'Corsican',\r\n  cr: 'Cree',\r\n  hr: 'Croatian',\r\n  cs: 'Czech',\r\n  da: 'Danish',\r\n  dv: 'Divehi',\r\n  nl: 'Dutch',\r\n  en: 'English',\r\n  eo: 'Esperanto',\r\n  et: 'Estonian',\r\n  ee: 'Ewe',\r\n  fo: 'Faroese',\r\n  fj: 'Fijian',\r\n  fi: 'Finnish',\r\n  fr: 'French',\r\n  ff: 'Fula',\r\n  gl: 'Galician',\r\n  ka: 'Georgian',\r\n  de: 'German',\r\n  el: 'Greek',\r\n  gu: 'Gujarati',\r\n  ht: 'Haitian',\r\n  ha: 'Hausa',\r\n  he: 'Hebrew',\r\n  hz: 'Herero',\r\n  hi: 'Hindi',\r\n  ho: 'Hiri Motu',\r\n  hu: 'Hungarian',\r\n  ia: 'Interlingua',\r\n  id: 'Indonesian',\r\n  ie: 'Interlingue',\r\n  ga: 'Irish',\r\n  ig: 'Igbo',\r\n  ik: 'Inupiaq',\r\n  io: 'Ido',\r\n  is: 'Icelandic',\r\n  it: 'Italian',\r\n  iu: 'Inuktitut',\r\n  ja: 'Japanese',\r\n  jv: 'Javanese',\r\n  kl: 'Kalaallisut',\r\n  kn: 'Kannada',\r\n  kr: 'Kanuri',\r\n  ks: 'Kashmiri',\r\n  kk: 'Kazakh',\r\n  km: 'Khmer',\r\n  ki: 'Kikuyu',\r\n  rw: 'Kinyarwanda',\r\n  ky: 'Kirghiz',\r\n  kv: 'Komi',\r\n  kg: 'Kongo',\r\n  ko: 'Korean',\r\n  ku: 'Kurdish',\r\n  kj: 'Kwanyama',\r\n  la: 'Latin',\r\n  lb: 'Luxembourgish',\r\n  lg: 'Luganda',\r\n  li: 'Limburgish',\r\n  ln: 'Lingala',\r\n  lo: 'Lao',\r\n  lt: 'Lithuanian',\r\n  lu: 'Luba-Katanga',\r\n  lv: 'Latvian',\r\n  gv: 'Manx',\r\n  mk: 'Macedonian',\r\n  mg: 'Malagasy',\r\n  ms: 'Malay',\r\n  ml: 'Malayalam',\r\n  mt: 'Maltese',\r\n  mh: 'Marshallese',\r\n  mn: 'Mongolian',\r\n  na: 'Nauru',\r\n  nv: 'Navajo',\r\n  nd: 'Ndebele',\r\n  ne: 'Nepali',\r\n  ng: 'Ndonga',\r\n  nn: 'Norwegian',\r\n  no: 'Norwegian',\r\n  ii: 'Nuosu',\r\n  nr: 'Ndebele',\r\n  oc: 'Occitan',\r\n  oj: 'Ojibwe',\r\n  om: 'Oromo',\r\n  or: 'Oriya',\r\n  os: 'Ossetian',\r\n  pa: 'Panjabi',\r\n  fa: 'Persian',\r\n  pl: 'Polish',\r\n  ps: 'Pashto',\r\n  pt: 'Portuguese',\r\n  qu: 'Quechua',\r\n  rm: 'Romansh',\r\n  rn: 'Kirundi',\r\n  ro: 'Romanian',\r\n  ru: 'Russian',\r\n  sc: 'Sardinian',\r\n  sd: 'Sindhi',\r\n  se: 'Sami',\r\n  sm: 'Samoan',\r\n  sg: 'Sango',\r\n  sr: 'Serbian',\r\n  gd: 'Gaelic',\r\n  sn: 'Shona',\r\n  si: 'Sinhala',\r\n  sk: 'Slovak',\r\n  sl: 'Slovene',\r\n  so: 'Somali',\r\n  st: 'Sotho',\r\n  es: 'Spanish',\r\n  su: 'Sundanese',\r\n  sw: 'Swahili',\r\n  ss: 'Swati',\r\n  sv: 'Swedish',\r\n  ta: 'Tamil',\r\n  te: 'Telugu',\r\n  tg: 'Tajik',\r\n  th: 'Thai',\r\n  ti: 'Tigrinya',\r\n  bo: 'Tibetan',\r\n  tk: 'Turkmen',\r\n  tl: 'Tagalog',\r\n  tn: 'Tswana',\r\n  to: 'Tonga',\r\n  tr: 'Turkish',\r\n  ts: 'Tsonga',\r\n  tt: 'Tatar',\r\n  tw: 'Twi',\r\n  ty: 'Tahitian',\r\n  ug: 'Uighur',\r\n  uk: 'Ukrainian',\r\n  ur: 'Urdu',\r\n  uz: 'Uzbek',\r\n  ve: 'Venda',\r\n  vi: 'Vietnamese',\r\n  wa: 'Walloon',\r\n  cy: 'Welsh',\r\n  wo: 'Wolof',\r\n  fy: 'Frisian',\r\n  xh: 'Xhosa',\r\n  yi: 'Yiddish',\r\n  yo: 'Yoruba',\r\n  za: 'Zhuang',\r\n}\r\n\r\nexport function get_dict_definition_url(dictUrl, text) {\r\n  return dictUrl + encodeURIComponent(text)\r\n}\r\n\r\nexport function showDefinition(dictUrl, text) {\r\n  const fullUrl = get_dict_definition_url(dictUrl, text)\r\n  chrome.tabs.create({ url: fullUrl }, function (tab) {\r\n    // opens definition in a new tab\r\n  })\r\n}\r\n\r\nexport function createDictionaryEntry(title, dictUrl, entryId) {\r\n  chrome.contextMenus.create({\r\n    title,\r\n    contexts: ['selection'],\r\n    id: entryId,\r\n    // onclick: function (info, tab) {\r\n    //   var word = info.selectionText\r\n    //   showDefinition(dictUrl, word)\r\n    // },\r\n  })\r\n  chrome.contextMenus.onClicked.addListener(function (info, tab) {\r\n    const word = info.selectionText\r\n    showDefinition(dictUrl, word)\r\n  })\r\n}\r\n\r\nexport function context_handle_add_result(report, lemma) {\r\n  if (report === 'ok') {\r\n    request_unhighlight(lemma)\r\n  }\r\n}\r\n\r\nexport function onClickHandler(info, tab) {\r\n  const word = info.selectionText\r\n  add_lexeme(word, context_handle_add_result)\r\n}\r\n\r\nexport function make_default_online_dicts() {\r\n  const result = []\r\n\r\n  let uiLang = chrome.i18n.getUILanguage()\r\n  uiLang = uiLang.split('-')[0]\r\n  if (uiLang !== 'en' && isoLangs.hasOwnProperty(uiLang)) {\r\n    const langName = isoLangs[uiLang]\r\n    result.push({\r\n      title: `Translate to ${langName} in Google`,\r\n      url: `https://translate.google.com/#en/${uiLang}/`,\r\n    })\r\n  }\r\n  result.push({\r\n    title: 'Define in Merriam-Webster',\r\n    url: 'https://www.merriam-webster.com/dictionary/',\r\n  })\r\n  result.push({\r\n    title: 'Define in Google',\r\n    url: 'https://encrypted.google.com/search?hl=en&gl=en&q=define:',\r\n  })\r\n  result.push({\r\n    title: 'View pictures in Google',\r\n    url: 'https://encrypted.google.com/search?hl=en&gl=en&tbm=isch&q=',\r\n  })\r\n  return result\r\n}\r\n\r\nexport function initContextMenus(dictPairs) {\r\n  chrome.contextMenus.removeAll(function () {\r\n    const title = chrome.i18n.getMessage('menuItem')\r\n    chrome.contextMenus.create({\r\n      title,\r\n      contexts: ['selection'],\r\n      id: 'vocab_select_add',\r\n      // onclick: onClickHandler,\r\n    })\r\n    chrome.contextMenus.onClicked.addListener(onClickHandler)\r\n    chrome.contextMenus.create({\r\n      type: 'separator',\r\n      contexts: ['selection'],\r\n      id: 'wd_separator_id',\r\n    })\r\n    for (let i = 0; i < dictPairs.length; ++i) {\r\n      createDictionaryEntry(\r\n        dictPairs[i].title,\r\n        dictPairs[i].url,\r\n        `wd_define_${i}`,\r\n      )\r\n    }\r\n  })\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { make_default_online_dicts, initContextMenus } from './context_menu_lib'\r\n\r\nlet gapi_loaded = false\r\nlet gapi_inited = false\r\n\r\n// TODO check chrome.runtime.lastError for all storage.local operations\r\n\r\nfunction do_load_dictionary(file_text) {\r\n  const lines = file_text.split('\\n')\r\n  const rare_words = {}\r\n  let rank = 0\r\n  let prev_lemma = null\r\n  for (let i = 0; i < lines.length; ++i) {\r\n    const fields = lines[i].split('\\t')\r\n    if (i + 1 === lines.length && fields.length === 1) break\r\n    const form = fields[0]\r\n    const lemma = fields[1]\r\n    if (lemma !== prev_lemma) {\r\n      rank += 1\r\n      prev_lemma = lemma\r\n    }\r\n    rare_words[fields[0]] = [fields[1], rank]\r\n  }\r\n  const local_storage = chrome.storage.local\r\n  local_storage.set({ words_discoverer_eng_dict: rare_words })\r\n  local_storage.set({ wd_word_max_rank: rank })\r\n}\r\n\r\nfunction load_eng_dictionary() {\r\n  const file_path = chrome.runtime.getURL('../assets/eng_dict.txt')\r\n  // var xhr = new XMLHttpRequest()\r\n  // xhr.onreadystatechange = function () {\r\n  //   if (xhr.readyState == XMLHttpRequest.DONE) {\r\n  //     do_load_dictionary(xhr.responseText)\r\n  //   }\r\n  // }\r\n  // xhr.open('GET', file_path, true)\r\n  // xhr.send(null)\r\n  fetch(file_path)\r\n    .then((res) => res.text())\r\n    .then(do_load_dictionary)\r\n}\r\n\r\nfunction do_load_idioms(file_text) {\r\n  const lines = file_text.split('\\n')\r\n  const rare_words = {}\r\n  for (let lno = 0; lno < lines.length; ++lno) {\r\n    const fields = lines[lno].split('\\t')\r\n    if (lno + 1 === lines.length && fields.length === 1) break\r\n    const words = fields[0].split(' ')\r\n    for (let i = 0; i + 1 < words.length; ++i) {\r\n      const key = words.slice(0, i + 1).join(' ')\r\n      rare_words[key] = -1\r\n    }\r\n    const key = fields[0]\r\n    rare_words[key] = fields[1]\r\n  }\r\n  const local_storage = chrome.storage.local\r\n  local_storage.set({ wd_idioms: rare_words })\r\n}\r\n\r\nfunction load_idioms() {\r\n  const file_path = chrome.runtime.getURL('../assets/eng_idioms.txt')\r\n  // var xhr = new XMLHttpRequest()\r\n  // xhr.onreadystatechange = function () {\r\n  //   if (xhr.readyState == XMLHttpRequest.DONE) {\r\n  //     do_load_idioms(xhr.responseText)\r\n  //   }\r\n  // }\r\n  // xhr.open('GET', file_path, true)\r\n  // xhr.send(null)\r\n  fetch(file_path)\r\n    .then((res) => res.text())\r\n    .then(do_load_idioms)\r\n}\r\n\r\nfunction report_sync_failure(error_msg) {\r\n  chrome.storage.local.set({ wd_last_sync_error: error_msg }, function () {\r\n    chrome.runtime.sendMessage({ sync_feedback: 1 })\r\n  })\r\n}\r\n\r\nfunction load_script(url, callback_func) {\r\n  const request = new XMLHttpRequest()\r\n  request.onreadystatechange = function () {\r\n    if (request.readyState !== 4) return\r\n    if (request.status !== 200) return\r\n    // eslint-disable-next-line no-eval\r\n    eval(request.responseText)\r\n    callback_func()\r\n  }\r\n  request.open('GET', url)\r\n  request.send()\r\n}\r\n\r\nfunction authorize_user(interactive_authorization) {\r\n  chrome.identity.getAuthToken(\r\n    { interactive: interactive_authorization },\r\n    function (token) {\r\n      if (token === undefined) {\r\n        report_sync_failure('Unable to get oauth token')\r\n      } else {\r\n        gapi.client.setToken({ access_token: token })\r\n        sync_user_vocabularies()\r\n      }\r\n    },\r\n  )\r\n}\r\n\r\nfunction transform_key(src_key) {\r\n  let dc = window.atob(src_key)\r\n  dc = dc.substring(3)\r\n  dc = dc.substring(0, dc.length - 6)\r\n  return dc\r\n}\r\n\r\nfunction generate_key() {\r\n  const protokey =\r\n    'b2ZCQUl6YVN5Q2hqM2xvZkJPWnV2TUt2TGNCSlVaa0RDTUhZa25NWktBa25NWktB'\r\n  return transform_key(protokey)\r\n}\r\n\r\nfunction list_to_set(src_list) {\r\n  const result = {}\r\n  for (let i = 0; i < src_list.length; ++i) {\r\n    result[src_list[i]] = 1\r\n  }\r\n  return result\r\n}\r\n\r\nfunction substract_from_set(lhs_set, rhs_set) {\r\n  // for (const key in rhs_set) {\r\n  //   if (rhs_set.hasOwnProperty(key) && lhs_set.hasOwnProperty(key)) {\r\n  //     delete lhs_set[key]\r\n  //   }\r\n  // }\r\n  Object.keys(rhs_set).forEach((key) => {\r\n    if (rhs_set.hasOwnProperty(key) && lhs_set.hasOwnProperty(key)) {\r\n      delete lhs_set[key]\r\n    }\r\n  })\r\n}\r\n\r\nfunction add_to_set(lhs_set, rhs_set) {\r\n  // for (const key in rhs_set) {\r\n  //   if (rhs_set.hasOwnProperty(key)) {\r\n  //     lhs_set[key] = 1\r\n  //   }\r\n  // }\r\n  Object.keys(rhs_set).forEach((key) => {\r\n    if (rhs_set.hasOwnProperty(key)) {\r\n      lhs_set[key] = 1\r\n    }\r\n  })\r\n}\r\n\r\nfunction serialize_vocabulary(entries) {\r\n  const keys = []\r\n  // for (const key in entries) {\r\n  //   if (entries.hasOwnProperty(key)) {\r\n  //     keys.push(key)\r\n  //   }\r\n  // }\r\n  Object.keys(entries).forEach((key) => {\r\n    if (entries.hasOwnProperty(key)) {\r\n      keys.push(key)\r\n    }\r\n  })\r\n  keys.sort()\r\n  return keys.join('\\r\\n')\r\n}\r\n\r\nfunction parse_vocabulary(text) {\r\n  // code duplication with parse_vocabulary in import.js\r\n  const lines = text.split('\\n')\r\n  const found = []\r\n  for (let i = 0; i < lines.length; ++i) {\r\n    let word = lines[i]\r\n    if (i + 1 === lines.length && word.length <= 1) break\r\n    if (word.slice(-1) === '\\r') {\r\n      word = word.slice(0, -1)\r\n    }\r\n    found.push(word)\r\n  }\r\n  return found\r\n}\r\n\r\nfunction create_new_dir(dir_name, success_cb) {\r\n  const body = {\r\n    name: dir_name,\r\n    mimeType: 'application/vnd.google-apps.folder',\r\n    appProperties: { wdfile: '1' },\r\n  }\r\n  const req_params = {\r\n    path: 'https://www.googleapis.com/drive/v3/files/',\r\n    method: 'POST',\r\n    body,\r\n  }\r\n  gapi.client.request(req_params).then(function (jsonResp, rawResp) {\r\n    if (jsonResp.status === 200) {\r\n      success_cb(jsonResp.result.id)\r\n    } else {\r\n      report_sync_failure(`Bad dir create status: ${jsonResp.status}`)\r\n    }\r\n  })\r\n}\r\n\r\nfunction create_new_file(fname, parent_dir_id, success_cb) {\r\n  const body = {\r\n    name: fname,\r\n    parents: [parent_dir_id],\r\n    appProperties: { wdfile: '1' },\r\n    mimeType: 'text/plain',\r\n  }\r\n  const req_params = {\r\n    path: 'https://www.googleapis.com/drive/v3/files',\r\n    method: 'POST',\r\n    body,\r\n  }\r\n  gapi.client.request(req_params).then(function (jsonResp, rawResp) {\r\n    if (jsonResp.status === 200) {\r\n      success_cb(jsonResp.result.id)\r\n    } else {\r\n      report_sync_failure(`Bad file create status: ${jsonResp.status}`)\r\n    }\r\n  })\r\n}\r\n\r\nfunction upload_file_content(file_id, file_content, success_cb) {\r\n  const req_params = {\r\n    path: `https://www.googleapis.com/upload/drive/v3/files/${file_id}`,\r\n    method: 'PATCH',\r\n    body: file_content,\r\n  }\r\n  gapi.client.request(req_params).then(function (jsonResp, rawResp) {\r\n    if (jsonResp.status === 200) {\r\n      success_cb()\r\n    } else {\r\n      report_sync_failure(`Bad upload content status: ${jsonResp.status}`)\r\n    }\r\n  })\r\n}\r\n\r\nfunction fetch_file_content(file_id, success_cb) {\r\n  // https://developers.google.com/drive/v3/web/manage-downloads\r\n  const full_query_url = `https://www.googleapis.com/drive/v3/files/${file_id}?alt=media`\r\n  gapi.client\r\n    .request({ path: full_query_url, method: 'GET' })\r\n    .then(function (jsonResp, rawResp) {\r\n      if (jsonResp.status !== 200) {\r\n        report_sync_failure(\r\n          `Bad status: ${jsonResp.status} for getting content of file: ${file_id}`,\r\n        )\r\n        return\r\n      }\r\n      const file_content = jsonResp.body\r\n      success_cb(file_id, file_content)\r\n    })\r\n}\r\n\r\nfunction find_gdrive_id(query, found_cb, not_found_cb) {\r\n  // generic function to find single object id\r\n  const full_query_url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(query)}`\r\n  gapi.client\r\n    .request({ path: full_query_url, method: 'GET' })\r\n    .then(function (jsonResp, rawResp) {\r\n      if (jsonResp.status !== 200) {\r\n        report_sync_failure(\r\n          `Bad status: ${jsonResp.status} for query: ${query}`,\r\n        )\r\n        return\r\n      }\r\n      if (jsonResp.result.files.length > 1) {\r\n        report_sync_failure(`More than one object found for query: ${query}`)\r\n        return\r\n      }\r\n      if (jsonResp.result.files.length === 1) {\r\n        const drive_id = jsonResp.result.files[0].id\r\n        found_cb(drive_id)\r\n        return\r\n      }\r\n      not_found_cb()\r\n    })\r\n}\r\n\r\nfunction apply_cloud_vocab(entries) {\r\n  const sync_date = new Date()\r\n  const sync_time = sync_date.getTime()\r\n  const new_state = {\r\n    wd_last_sync_error: null,\r\n    wd_user_vocabulary: entries,\r\n    wd_user_vocab_added: {},\r\n    wd_user_vocab_deleted: {},\r\n    wd_last_sync: sync_time,\r\n  }\r\n  chrome.storage.local.set(new_state, function () {\r\n    chrome.runtime.sendMessage({ sync_feedback: 1 })\r\n  })\r\n}\r\n\r\nfunction sync_vocabulary(dir_id, vocab) {\r\n  const merge_and_upload_vocab = function (file_id, file_content) {\r\n    const vocab_list = parse_vocabulary(file_content)\r\n    const entries = list_to_set(vocab_list)\r\n    substract_from_set(entries, vocab.deleted)\r\n    add_to_set(entries, vocab.added)\r\n    const merged_content = serialize_vocabulary(entries)\r\n\r\n    const set_merged_vocab = function () {\r\n      apply_cloud_vocab(entries)\r\n    }\r\n    upload_file_content(file_id, merged_content, set_merged_vocab)\r\n  }\r\n\r\n  const merge_vocab_to_cloud = function (file_id) {\r\n    fetch_file_content(file_id, merge_and_upload_vocab)\r\n  }\r\n\r\n  const vocab_file_name = `${vocab.name}.txt`\r\n  const file_query = `name = '${vocab_file_name}' and trashed = false and appProperties has { key='wdfile' and value='1' } and '${dir_id}' in parents`\r\n  const create_new_file_wrap = function () {\r\n    create_new_file(vocab_file_name, dir_id, merge_vocab_to_cloud)\r\n    const new_added = {}\r\n    add_to_set(new_added, vocab.all)\r\n    add_to_set(new_added, vocab.added)\r\n    vocab.added = new_added\r\n  }\r\n  find_gdrive_id(file_query, merge_vocab_to_cloud, create_new_file_wrap)\r\n}\r\n\r\nfunction backup_vocabulary(dir_id, vocab, success_cb) {\r\n  const merge_and_upload_backup = function (file_id, file_content) {\r\n    const vocab_list = parse_vocabulary(file_content)\r\n    const entries = list_to_set(vocab_list)\r\n    add_to_set(entries, vocab.all)\r\n    add_to_set(entries, vocab.deleted)\r\n    add_to_set(entries, vocab.added)\r\n    const merged_content = serialize_vocabulary(entries)\r\n    upload_file_content(file_id, merged_content, success_cb)\r\n  }\r\n  const merge_backup_to_cloud = function (file_id) {\r\n    fetch_file_content(file_id, merge_and_upload_backup)\r\n  }\r\n\r\n  const backup_file_name = `.${vocab.name}.backup`\r\n  const backup_query = `name = '${backup_file_name}' and trashed = false and appProperties has { key='wdfile' and value='1' } and '${dir_id}' in parents`\r\n  const create_new_backup_file_wrap = function () {\r\n    create_new_file(backup_file_name, dir_id, merge_backup_to_cloud)\r\n  }\r\n  find_gdrive_id(\r\n    backup_query,\r\n    merge_backup_to_cloud,\r\n    create_new_backup_file_wrap,\r\n  )\r\n}\r\n\r\nfunction perform_full_sync(vocab) {\r\n  const dir_name = 'Words Discoverer Sync'\r\n  const dir_query = `name = '${dir_name}' and trashed = false and appProperties has { key='wdfile' and value='1' }`\r\n  const backup_and_sync_vocabulary = function (dir_id) {\r\n    const sync_vocabulary_wrap = function () {\r\n      sync_vocabulary(dir_id, vocab)\r\n    }\r\n    backup_vocabulary(dir_id, vocab, sync_vocabulary_wrap)\r\n  }\r\n  const create_new_dir_wrap = function () {\r\n    create_new_dir(dir_name, backup_and_sync_vocabulary)\r\n  }\r\n  find_gdrive_id(dir_query, backup_and_sync_vocabulary, create_new_dir_wrap)\r\n}\r\n\r\nfunction sync_user_vocabularies() {\r\n  chrome.storage.local.get(\r\n    ['wd_user_vocabulary', 'wd_user_vocab_added', 'wd_user_vocab_deleted'],\r\n    function (result) {\r\n      let { wd_user_vocabulary } = result\r\n      let { wd_user_vocab_added } = result\r\n      let { wd_user_vocab_deleted } = result\r\n      if (typeof wd_user_vocabulary === 'undefined') {\r\n        wd_user_vocabulary = {}\r\n      }\r\n      if (typeof wd_user_vocab_added === 'undefined') {\r\n        wd_user_vocab_added = { ...wd_user_vocabulary }\r\n      }\r\n      if (typeof wd_user_vocab_deleted === 'undefined') {\r\n        wd_user_vocab_deleted = {}\r\n      }\r\n      const vocab = {\r\n        name: 'my_vocabulary',\r\n        all: wd_user_vocabulary,\r\n        added: wd_user_vocab_added,\r\n        deleted: wd_user_vocab_deleted,\r\n      }\r\n      perform_full_sync(vocab)\r\n    },\r\n  )\r\n}\r\n\r\nfunction init_gapi(interactive_authorization) {\r\n  const gapikey = generate_key()\r\n  const init_params = { apiKey: gapikey }\r\n  gapi.client.init(init_params).then(\r\n    function () {\r\n      gapi_inited = true\r\n      authorize_user(interactive_authorization)\r\n    },\r\n    function (reject_reason) {\r\n      const error_msg = `Unable to init client. Reject reason: ${reject_reason}`\r\n      console.error(error_msg)\r\n      report_sync_failure(error_msg)\r\n    },\r\n  )\r\n}\r\n\r\nfunction load_and_init_gapi(interactive_authorization) {\r\n  load_script('https://apis.google.com/js/api.js', function () {\r\n    gapi.load('client', function () {\r\n      gapi_loaded = true\r\n      init_gapi(interactive_authorization)\r\n    })\r\n  })\r\n}\r\n\r\nfunction start_sync_sequence(interactive_authorization) {\r\n  chrome.storage.local.set(\r\n    { wd_last_sync_error: 'Unknown sync problem' },\r\n    function () {\r\n      if (!gapi_loaded) {\r\n        load_and_init_gapi(interactive_authorization)\r\n      } else if (!gapi_inited) {\r\n        init_gapi(interactive_authorization)\r\n      } else {\r\n        authorize_user(interactive_authorization)\r\n      }\r\n    },\r\n  )\r\n}\r\n\r\nfunction initialize_extension() {\r\n  chrome.runtime.onMessage.addListener(\r\n    function (request, sender, sendResponse) {\r\n      if (request.type === 'fetch') {\r\n        console.log('request', request)\r\n        fetch(\r\n          `https://cn.bing.com/dict/clientsearch?mkt=zh-CN&setLang=zh&form=BDVEHC&ClientVer=BDDTV3.5.1.4320&q=${request.q}`,\r\n        )\r\n          .then((response) => response.text())\r\n          .then(sendResponse)\r\n        return true // Will respond asynchronously.\r\n      }\r\n      if (request.wdm_request === 'hostname') {\r\n        const tab_url = sender.tab.url\r\n        const url = new URL(tab_url)\r\n        const domain = url.hostname\r\n        sendResponse({ wdm_hostname: domain })\r\n      } else if (request.wdm_request === 'page_language') {\r\n        chrome.tabs.detectLanguage(sender.tab.id, function (iso_language_code) {\r\n          sendResponse({ wdm_iso_language_code: iso_language_code })\r\n        })\r\n        return true // This is to indicate that sendResponse would be sent asynchronously and keep the message channel open, see https://developer.chrome.com/extensions/runtime#event-onMessage\r\n      } else if (request.wdm_verdict) {\r\n        if (request.wdm_verdict === 'highlight') {\r\n          chrome.storage.local.get(\r\n            ['wd_gd_sync_enabled', 'wd_last_sync_error'],\r\n            function (result) {\r\n              chrome.action.setIcon(\r\n                { path: '../assets/result48.png', tabId: sender.tab.id },\r\n                function () {\r\n                  if (result.wd_gd_sync_enabled) {\r\n                    if (result.wd_last_sync_error == null) {\r\n                      chrome.action.setBadgeText({\r\n                        text: 'sync',\r\n                        tabId: sender.tab.id,\r\n                      })\r\n                      chrome.action.setBadgeBackgroundColor({\r\n                        color: [25, 137, 0, 255],\r\n                        tabId: sender.tab.id,\r\n                      })\r\n                    } else {\r\n                      chrome.action.setBadgeText({\r\n                        text: 'err',\r\n                        tabId: sender.tab.id,\r\n                      })\r\n                      chrome.action.setBadgeBackgroundColor({\r\n                        color: [137, 0, 0, 255],\r\n                        tabId: sender.tab.id,\r\n                      })\r\n                    }\r\n                  }\r\n                },\r\n              )\r\n            },\r\n          )\r\n        } else if (request.wdm_verdict === 'keyboard') {\r\n          chrome.action.setIcon({\r\n            path: '../assets/no_dynamic.png',\r\n            tabId: sender.tab.id,\r\n          })\r\n        } else {\r\n          chrome.action.setIcon({\r\n            path: '../assets/result48_gray.png',\r\n            tabId: sender.tab.id,\r\n          })\r\n        }\r\n      } else if (request.wdm_new_tab_url) {\r\n        const fullUrl = request.wdm_new_tab_url\r\n        chrome.tabs.create({ url: fullUrl }, function (tab) {})\r\n      } else if (request.wdm_request === 'gd_sync') {\r\n        start_sync_sequence(request.interactive_mode)\r\n      }\r\n    },\r\n  )\r\n\r\n  chrome.storage.local.get(\r\n    [\r\n      'words_discoverer_eng_dict',\r\n      'wd_hl_settings',\r\n      'wd_online_dicts',\r\n      'wd_hover_settings',\r\n      'wd_idioms',\r\n      'wd_show_percents',\r\n      'wd_is_enabled',\r\n      'wd_user_vocabulary',\r\n      'wd_black_list',\r\n      'wd_white_list',\r\n      'wd_gd_sync_enabled',\r\n      'wd_enable_tts',\r\n    ],\r\n    function (result) {\r\n      load_eng_dictionary()\r\n      load_idioms()\r\n      let { wd_hl_settings } = result\r\n      if (typeof wd_hl_settings === 'undefined') {\r\n        const word_hl_params = {\r\n          enabled: true,\r\n          quoted: false,\r\n          bold: true,\r\n          useBackground: false,\r\n          backgroundColor: 'rgb(255, 248, 220)',\r\n          useColor: true,\r\n          color: 'red',\r\n        }\r\n        const idiom_hl_params = {\r\n          enabled: true,\r\n          quoted: false,\r\n          bold: true,\r\n          useBackground: false,\r\n          backgroundColor: 'rgb(255, 248, 220)',\r\n          useColor: true,\r\n          color: 'blue',\r\n        }\r\n        wd_hl_settings = {\r\n          wordParams: word_hl_params,\r\n          idiomParams: idiom_hl_params,\r\n        }\r\n        chrome.storage.local.set({ wd_hl_settings })\r\n      }\r\n      const { wd_enable_tts } = result\r\n      if (typeof wd_enable_tts === 'undefined') {\r\n        chrome.storage.local.set({ wd_enable_tts: false })\r\n      }\r\n      let { wd_hover_settings } = result\r\n      if (typeof wd_hover_settings === 'undefined') {\r\n        wd_hover_settings = { hl_hover: 'always', ow_hover: 'never' }\r\n        chrome.storage.local.set({ wd_hover_settings })\r\n      }\r\n      let { wd_online_dicts } = result\r\n      if (typeof wd_online_dicts === 'undefined') {\r\n        wd_online_dicts = make_default_online_dicts()\r\n        chrome.storage.local.set({ wd_online_dicts })\r\n      }\r\n      initContextMenus(wd_online_dicts)\r\n\r\n      const show_percents = result.wd_show_percents\r\n      if (typeof show_percents === 'undefined') {\r\n        chrome.storage.local.set({ wd_show_percents: 15 })\r\n      }\r\n      const { wd_is_enabled } = result\r\n      if (typeof wd_is_enabled === 'undefined') {\r\n        chrome.storage.local.set({ wd_is_enabled: true })\r\n      }\r\n      const user_vocabulary = result.wd_user_vocabulary\r\n      if (typeof user_vocabulary === 'undefined') {\r\n        chrome.storage.local.set({ wd_user_vocabulary: {} })\r\n      }\r\n      const black_list = result.wd_black_list\r\n      if (typeof black_list === 'undefined') {\r\n        chrome.storage.local.set({ wd_black_list: {} })\r\n      }\r\n      const white_list = result.wd_white_list\r\n      if (typeof white_list === 'undefined') {\r\n        chrome.storage.local.set({ wd_white_list: {} })\r\n      }\r\n    },\r\n  )\r\n\r\n  chrome.runtime.onMessage.addListener(\r\n    function (request, sender, sendResponse) {\r\n      if ((request.type = 'tts_speak')) {\r\n        if (!!request.word && typeof request.word === 'string') {\r\n          chrome.tts.speak(request.word, { lang: 'en', gender: 'male' })\r\n        }\r\n      }\r\n    },\r\n  )\r\n}\r\n\r\ninitialize_extension()\r\n"],"names":[],"sourceRoot":""}